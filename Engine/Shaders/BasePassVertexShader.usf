// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	BasePassVertexShader.usf: Base pass vertex shader
=============================================================================*/

#include "BasePassVertexCommon.usf"

#if WRITES_VELOCITY_TO_GBUFFER
//@todo-rco: Move to pixel shader
float SkipOutputVelocity;
#endif

#if TRANSLUCENCY_PERVERTEX_FORWARD_SHADING
#include "ReflectionEnvironmentShared.usf"
#include "ForwardLightingCommon.usf"
#endif

/** Entry point for the base pass vertex shader. */
void Main(
	FVertexFactoryInput Input,
	OPTIONAL_VertexID
	out FBasePassVSOutput Output
#if USE_GLOBAL_CLIP_PLANE && !USING_TESSELLATION
	, out float OutGlobalClipPlaneDistance : SV_ClipDistance
#endif
#if INSTANCED_STEREO
	, uint InstanceId : SV_InstanceID
	#if !MULTI_VIEW
		, out float OutClipDistance : SV_ClipDistance1
	#else
		, out uint ViewportIndex : SV_ViewPortArrayIndex
	#endif
#endif
	)
{	
#if INSTANCED_STEREO
	const uint EyeIndex = VertexFactoryGetEyeIndex(InstanceId);
	ResolvedView = ResolveView(EyeIndex);
	#if !MULTI_VIEW
		OutClipDistance = 0.0;
	#else
		ViewportIndex = EyeIndex;
	#endif
#else
	uint EyeIndex = 0;
	ResolvedView = ResolveView();
#endif

#if SINGLE_PASS_STEREO
	ResolvedViewRight = ResolveView(1);
	float4 WorldPositionRight = 0;
	float4 OutputPositionRight = 0;
#endif

	FVertexFactoryIntermediates VFIntermediates = GetVertexFactoryIntermediates(Input);
	float4 WorldPositionExcludingWPO = VertexFactoryGetWorldPosition(Input, VFIntermediates);
	float4 WorldPosition = WorldPositionExcludingWPO;
	float4 ClipSpacePosition;

	float3x3 TangentToLocal = VertexFactoryGetTangentToLocal(Input, VFIntermediates);	
	FMaterialVertexParameters VertexParameters = GetMaterialVertexParameters(Input, VFIntermediates, WorldPosition.xyz, TangentToLocal);

	// Isolate instructions used for world position offset
	// As these cause the optimizer to generate different position calculating instructions in each pass, resulting in self-z-fighting.
	// This is only necessary for shaders used in passes that have depth testing enabled.
	ISOLATE
	{
		WorldPosition.xyz += GetMaterialWorldPositionOffset(VertexParameters);
	}

#if USING_TESSELLATION
	// We let the Domain Shader convert to post projection when tessellating
	Output.Position = WorldPosition;	

	#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
		Output.BasePassInterpolants.WorldPositionExcludingWPO = WorldPositionExcludingWPO.xyz;
	#endif

#else
	ISOLATE
	{
		float4 RasterizedWorldPosition = VertexFactoryGetRasterizedWorldPosition(Input, VFIntermediates, WorldPosition);
		ClipSpacePosition = mul(RasterizedWorldPosition, ResolvedView.TranslatedWorldToClip);
		Output.Position = ClipSpacePosition;

		#if SINGLE_PASS_STEREO
		BRANCH
		if (bIsSinglePassStereo)
		{
			WorldPositionRight = WorldPosition;
			WorldPositionRight.xyz -= ResolvedView.PreViewTranslation.xyz;
			WorldPositionRight.xyz += ResolvedViewRight.PreViewTranslation.xyz;
			RasterizedWorldPosition = VertexFactoryGetRasterizedWorldPosition(Input, VFIntermediates, WorldPositionRight);
			OutputPositionRight = mul(RasterizedWorldPosition, ResolvedViewRight.TranslatedWorldToClip);
			Output.NvXRight = OutputPositionRight.x;
		}
		else
		{
			Output.NvXRight = 0;
		}
		#endif

	#if INSTANCED_STEREO && !MULTI_VIEW
	BRANCH
	if (bIsInstancedStereo && !LensMatchedShadingIsActive())
	{
		// Clip at the center of the screen
		OutClipDistance = dot(Output.Position, EyeClipEdge[EyeIndex]);

		// Scale to the width of a single eye viewport
		Output.Position.x *= 0.5 * ResolvedView.HMDEyePaddingOffset;

		// Shift to the eye viewport
		Output.Position.x += (EyeOffsetScale[EyeIndex] * Output.Position.w) * (1.0f - 0.5 * ResolvedView.HMDEyePaddingOffset);
	}
	#endif
	}
	
#if USE_GLOBAL_CLIP_PLANE
	OutGlobalClipPlaneDistance = dot(ResolvedView.GlobalClippingPlane, float4(WorldPosition.xyz - ResolvedView.PreViewTranslation.xyz, 1));
#endif
	#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
		Output.BasePassInterpolants.PixelPositionExcludingWPO = WorldPositionExcludingWPO.xyz;
		#if SINGLE_PASS_STEREO
		Output.BasePassInterpolants.PixelPositionExcludingWPORight = WorldPositionExcludingWPO.xyz - ResolvedView.PreViewTranslation.xyz + ResolvedViewRight.PreViewTranslation.xyz;
		#endif
	#endif
#endif	// USING_TESSELLATION

	Output.FactoryInterpolants = VertexFactoryGetInterpolants(Input, VFIntermediates, VertexParameters);

#if INSTANCED_STEREO
	#if USING_TESSELLATION	
		Output.FactoryInterpolants.InterpolantsVSToPS.PackedEyeIndex = PackEyeIndex(EyeIndex, bIsInstancedStereo);
	#else
		Output.FactoryInterpolants.PackedEyeIndex = PackEyeIndex(EyeIndex, bIsInstancedStereo);
	#endif
#endif

// Calculate the fog needed for translucency
#if NEEDS_BASEPASS_FOGGING
	#if BASEPASS_ATMOSPHERIC_FOG
	Output.BasePassInterpolants.VertexFog = CalculateVertexAtmosphericFog(WorldPosition.xyz, ResolvedView.TranslatedWorldCameraOrigin);
		#if SINGLE_PASS_STEREO
		Output.BasePassInterpolants.VertexFogRight = CalculateVertexAtmosphericFog(WorldPositionRight.xyz, ResolvedViewRight.TranslatedWorldCameraOrigin);
		#endif
	#else
	Output.BasePassInterpolants.VertexFog = CalculateVertexHeightFog(WorldPosition.xyz - ResolvedView.TranslatedWorldCameraOrigin);
		#if SINGLE_PASS_STEREO
		Output.BasePassInterpolants.VertexFogRight = CalculateVertexHeightFog(WorldPositionRight.xyz - float4(ResolvedViewRight.TranslatedWorldCameraOrigin, 1));
		#endif
	#endif
#endif

#if TRANSLUCENCY_PERVERTEX_LIGHTING_VOLUME
	float4 VolumeLighting;
	float3 InterpolatedLighting = 0;

	float3 InnerVolumeUVs;
	float3 OuterVolumeUVs;
	float FinalLerpFactor;

	//@todo - get from VF
	float3 LightingPositionOffset = 0;
	float3 WorldPositionForVertexLighting = VertexFactoryGetPositionForVertexLighting(Input, VFIntermediates, WorldPosition.xyz);
	ComputeVolumeUVs(WorldPositionForVertexLighting - ResolvedView.PreViewTranslation.xyz, LightingPositionOffset, InnerVolumeUVs, OuterVolumeUVs, FinalLerpFactor);
	#if SINGLE_PASS_STEREO
		WorldPositionForVertexLightingRight = VertexFactoryGetPositionForVertexLighting(Input, VFIntermediates, WorldPositionRight.xyz);
	
		float3 InnerVolumeUVsRight;
		float3 OuterVolumeUVsRight;
		float3 LightingPositionOffsetRight = 0;
		ComputeVolumeUVs(WorldPositionForVertexLightingRight - ResolvedViewRight.PreViewTranslation.xyz, LightingPositionOffsetRight, InnerVolumeUVsRight, OuterVolumeUVsRight, FinalLerpFactor);
	#endif

	#if TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_DIRECTIONAL
	
		Output.BasePassInterpolants.AmbientLightingVector = GetAmbientLightingVectorFromTranslucentLightingVolume(InnerVolumeUVs, OuterVolumeUVs, FinalLerpFactor).xyz;
		Output.BasePassInterpolants.DirectionalLightingVector = GetDirectionalLightingVectorFromTranslucentLightingVolume(InnerVolumeUVs, OuterVolumeUVs, FinalLerpFactor);
		#if SINGLE_PASS_STEREO
		Output.BasePassInterpolants.AmbientLightingVectorRight = GetAmbientLightingVectorFromTranslucentLightingVolume(InnerVolumeUVsRight, OuterVolumeUVsRight, FinalLerpFactor).xyz;
		Output.BasePassInterpolants.DirectionalLightingVectorRight = GetDirectionalLightingVectorFromTranslucentLightingVolume(InnerVolumeUVsRight, OuterVolumeUVsRight, FinalLerpFactor);
		#endif

	#elif TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL

		Output.BasePassInterpolants.AmbientLightingVector = GetAmbientLightingVectorFromTranslucentLightingVolume(InnerVolumeUVs, OuterVolumeUVs, FinalLerpFactor).xyz;
		#if SINGLE_PASS_STEREO
		Output.BasePassInterpolants.AmbientLightingVectorRight = GetAmbientLightingVectorFromTranslucentLightingVolume(InnerVolumeUVsRight, OuterVolumeUVsRight, FinalLerpFactor).xyz;
		#endif

	#endif
#elif TRANSLUCENCY_PERVERTEX_FORWARD_SHADING

	float3 WorldPositionForVertexLighting = VertexFactoryGetPositionForVertexLighting(Input, VFIntermediates, WorldPosition.xyz);
	float4 VertexLightingClipSpacePosition = mul(WorldPositionForVertexLighting, ResolvedView.TranslatedWorldToClip);
	float2 SvPosition = (VertexLightingClipSpacePosition.xy / VertexLightingClipSpacePosition.w * float2(.5f, -.5f) + .5f) * ResolvedView.ViewSizeAndInvSize.xy;
	uint GridIndex = ComputeLightGridCellIndex((uint2)SvPosition, VertexLightingClipSpacePosition.w, EyeIndex);
	float3 AbsoluteWorldPosition = WorldPositionForVertexLighting - ResolvedView.PreViewTranslation.xyz;
	Output.BasePassInterpolants.VertexDiffuseLighting = GetForwardDirectLightingForVertexLighting(GridIndex, AbsoluteWorldPosition, VertexParameters.TangentToWorld[2], EyeIndex);

#endif


#if WRITES_VELOCITY_TO_GBUFFER
	{
		float4 PrevTranslatedWorldPosition = VertexFactoryGetPreviousWorldPosition( Input, VFIntermediates );	
		VertexParameters = GetMaterialVertexParameters(Input, VFIntermediates, PrevTranslatedWorldPosition.xyz, TangentToLocal);
		PrevTranslatedWorldPosition.xyz += GetMaterialPreviousWorldPositionOffset(VertexParameters);
		#if SINGLE_PASS_STEREO
			float4 PrevTranslatedWorldPositionRight = VertexFactoryGetPreviousWorldPosition(Input, VFIntermediates);
			VertexParameters = GetMaterialVertexParameters(Input, VFIntermediates, PrevTranslatedWorldPositionRight.xyz, TangentToLocal);
			PrevTranslatedWorldPositionRight.xyz += GetMaterialPreviousWorldPositionOffset(VertexParameters);
		#endif

		#if USING_TESSELLATION
			// We let the Domain Shader convert to post projection when tessellating
			Output.BasePassInterpolants.VelocityPrevScreenPosition = PrevTranslatedWorldPosition;
			// Store the mask in .w when doing tessellation as we need the world space Z
			Output.BasePassInterpolants.VelocityPrevScreenPosition.w = 1 - SkipOutputVelocity;
			#if SINGLE_PASS_STEREO
				Output.BasePassInterpolants.VelocityPrevScreenPositionRight = PrevTranslatedWorldPositionRight;
				Output.BasePassInterpolants.VelocityPrevScreenPositionRight.w = 1 - SkipOutputVelocity;
			#endif
			#if WRITES_VELOCITY_TO_GBUFFER_USE_POS_INTERPOLATOR
			Output.BasePassInterpolants.VelocityScreenPosition = WorldPosition;
				#if SINGLE_PASS_STEREO
				Output.BasePassInterpolants.VelocityScreenPositionRight = WorldPositionRight;
				#endif
			#endif
		#else
			// compute the old screen pos with the old world position and the old camera matrix
			Output.BasePassInterpolants.VelocityPrevScreenPosition = mul(float4(PrevTranslatedWorldPosition.xyz, 1), ResolvedView.PrevTranslatedWorldToClip);		
			// Store the mask in .z when as we don't need the clip space Z
			Output.BasePassInterpolants.VelocityPrevScreenPosition.z = 1 - SkipOutputVelocity;
			#if SINGLE_PASS_STEREO
				Output.BasePassInterpolants.VelocityPrevScreenPositionRight = mul(float4(PrevTranslatedWorldPositionRight.xyz, 1), ResolvedViewRight.PrevTranslatedWorldToClip);
				Output.BasePassInterpolants.VelocityPrevScreenPositionRight.z = 1 - SkipOutputVelocity;
			#endif
			#if WRITES_VELOCITY_TO_GBUFFER_USE_POS_INTERPOLATOR
			Output.BasePassInterpolants.VelocityScreenPosition = ClipSpacePosition;
				#if SINGLE_PASS_STEREO
				Output.BasePassInterpolants.VelocityScreenPositionRight = OutputPositionRight;
				#endif
			#endif
		#endif	// USING_TESSELLATION
	}
#endif	// WRITES_VELOCITY_TO_GBUFFER

	OutputVertexID( Output );
}

#if SINGLE_PASS_STEREO && INSTANCED_STEREO
VRPROJECT_CREATE_FASTGS_SPS_INSTANCED_STEREO(VRProjectFastGS, FBasePassVSToPS, Position, NvXRight, FactoryInterpolants.PackedEyeIndex)
#elif SINGLE_PASS_STEREO
VRPROJECT_CREATE_FASTGS_SPS(VRProjectFastGS, FBasePassVSToPS, Position, NvXRight)
#elif INSTANCED_STEREO
VRPROJECT_CREATE_FASTGS_INSTANCED_STEREO(VRProjectFastGS, FBasePassVSToPS, Position, FactoryInterpolants.PackedEyeIndex)
#else
VRPROJECT_CREATE_FASTGS(VRProjectFastGS, FBasePassVSToPS, Position)
#endif
